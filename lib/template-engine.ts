import { readFileSync } from 'fs';
import { join } from 'path';

export interface TemplateData {
  businessName: string;
  industry: string;
  documentType: string;
  letterhead: boolean;
  branding: {
    primaryColor?: string;
    accentColor?: string;
    footerNote?: string;
    headerText?: string;
  };
  placeholders: Record<string, string>;
}

export interface TemplateBlock {
  title: string;
  content: string;
  order: number;
}

export class TemplateEngine {
  private templatesPath: string;

  constructor() {
    this.templatesPath = join(process.cwd(), 'templates');
  }

  async buildHtmlFromTemplates(data: TemplateData): Promise<string> {
    const baseTemplate = data.letterhead ? 'base-letterhead.html' : 'base-plain.html';
    const templatePath = join(this.templatesPath, baseTemplate);
    
    let html: string;
    try {
      html = readFileSync(templatePath, 'utf-8');
    } catch (error) {
      console.warn(`Template file not found at ${templatePath}, using default template`);
      html = this.getDefaultHtmlTemplate(data.letterhead);
    }

    const contentBlocks = await this.getContentBlocks(data.industry, data.documentType);
    const processedContent = this.processContentBlocks(contentBlocks);

    html = this.replacePlaceholders(html, {
      ...data.placeholders,
      BUSINESS_NAME: data.businessName,
      DOCUMENT_TYPE: data.documentType,
      INDUSTRY: data.industry,
      CONTENT: processedContent,
      DATE: new Date().toLocaleDateString('en-AU'),
      PRIMARY_COLOR: data.branding.primaryColor || '#2563eb',
      ACCENT_COLOR: data.branding.accentColor || '#1e40af',
      HEADER_TEXT: data.branding.headerText || data.businessName,
      FOOTER_NOTE: data.branding.footerNote || `Generated by ${data.businessName}`,
    });

    return html;
  }

  async buildDocxFromTemplates(data: TemplateData): Promise<Buffer> {
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = await import('docx');
    
    const contentBlocks = await this.getContentBlocks(data.industry, data.documentType);
    const paragraphs: any[] = [];

    if (data.letterhead && data.branding.headerText) {
      paragraphs.push(
        new Paragraph({
          text: data.branding.headerText,
          heading: HeadingLevel.TITLE,
          alignment: AlignmentType.CENTER,
        })
      );
    }

    paragraphs.push(
      new Paragraph({
        text: data.businessName,
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({
        text: data.documentType,
        heading: HeadingLevel.HEADING_2,
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({ text: '' })
    );

    for (const block of contentBlocks) {
      paragraphs.push(
        new Paragraph({
          text: block.title,
          heading: HeadingLevel.HEADING_2,
        })
      );

      const lines = block.content.split('\n').filter(line => line.trim());
      for (const line of lines) {
        paragraphs.push(
          new Paragraph({
            children: [new TextRun({ text: line, size: 24 })]
          })
        );
      }
    }

    if (data.letterhead && data.branding.footerNote) {
      paragraphs.push(
        new Paragraph({ text: '' }),
        new Paragraph({
          text: data.branding.footerNote,
          alignment: AlignmentType.CENTER,
        })
      );
    }

    const doc = new Document({
      sections: [{ properties: {}, children: paragraphs }],
    });

    return await Packer.toBuffer(doc);
  }

  private async getContentBlocks(industry: string, documentType: string): Promise<TemplateBlock[]> {
    const paths = [
      join(this.templatesPath, 'blocks', industry, `${documentType}.json`),
      join(this.templatesPath, 'blocks', '_generic', `${documentType}.json`),
    ];

    for (const path of paths) {
      try {
        const content = readFileSync(path, 'utf-8');
        return JSON.parse(content);
      } catch (error) {
        console.warn(`Content block not found at ${path}, trying next path`);
        continue;
      }
    }

    console.warn(`No content blocks found for ${industry}/${documentType}, using defaults`);
    return this.getDefaultContentBlocks(documentType);
  }

  private processContentBlocks(blocks: TemplateBlock[]): string {
    return blocks
      .sort((a, b) => a.order - b.order)
      .map(block => `<h2>${block.title}</h2>\n${block.content}`)
      .join('\n\n');
  }

  private replacePlaceholders(template: string, placeholders: Record<string, string>): string {
    let result = template;
    for (const [key, value] of Object.entries(placeholders)) {
      const regex = new RegExp(`{{${key}}}`, 'g');
      result = result.replace(regex, value || '');
    }
    return result;
  }

  private getDefaultHtmlTemplate(letterhead: boolean): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{DOCUMENT_TYPE}} - {{BUSINESS_NAME}}</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; line-height: 1.6; color: #333; margin: 2cm; }
        .header { text-align: center; border-bottom: 3px solid {{PRIMARY_COLOR}}; padding-bottom: 20px; margin-bottom: 30px; }
        .business-name { font-size: 28px; font-weight: bold; color: {{PRIMARY_COLOR}}; margin-bottom: 8px; }
        .document-title { font-size: 24px; font-weight: bold; color: #1f2937; }
        h2 { color: {{PRIMARY_COLOR}}; margin-top: 25px; margin-bottom: 15px; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; font-size: 12px; color: #6b7280; }
    </style>
</head>
<body>
    ${letterhead ? '<div class="header"><div class="business-name">{{BUSINESS_NAME}}</div></div>' : ''}
    <div class="document-title">{{DOCUMENT_TYPE}}</div>
    <div class="content">{{CONTENT}}</div>
    <div class="footer"><p>{{FOOTER_NOTE}} | Generated on {{DATE}}</p></div>
</body>
</html>`;
  }

  private getDefaultContentBlocks(documentType: string): TemplateBlock[] {
    return [
      {
        title: "Purpose and Scope",
        content: `This ${documentType} outlines the policies and procedures for our organization.`,
        order: 1
      },
      {
        title: "Policy Statement",
        content: "Our organization is committed to maintaining the highest standards of compliance and operational excellence.",
        order: 2
      },
      {
        title: "Responsibilities",
        content: "All staff members are responsible for adhering to the policies outlined in this document.",
        order: 3
      }
    ];
  }
}
