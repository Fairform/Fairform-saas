import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { getServiceRoleClient } from '@/lib/supabase';
import { generateDocumentContent } from '@/lib/openaiDoc';
import { TemplateEngine } from '@/lib/template-engine';
import { generatePdf } from '@/utils/pdfBuilder';
import { BusinessInfo } from '@/types';

const generateSchema = z.object({
  businessName: z.string().min(1),
  industry: z.string().min(1),
  documentType: z.string().min(1),
  letterhead: z.boolean().default(false),
  format: z.array(z.enum(['pdf', 'docx'])).min(1),
  branding: z.object({
    primaryColor: z.string().optional(),
    accentColor: z.string().optional(),
    footerNote: z.string().optional(),
    headerText: z.string().optional(),
  }).optional(),
  placeholders: z.record(z.string()).default({}),
});

export async function POST(req: NextRequest) {
  const supabase = getServiceRoleClient();

  try {
    const body = await req.json();
    console.log('API received body:', JSON.stringify(body, null, 2));
    
    const parsed = generateSchema.safeParse(body);
    
    if (!parsed.success) {
      console.log('Validation failed:', parsed.error.flatten());
      return NextResponse.json({ 
        error: 'Invalid input', 
        details: parsed.error.flatten() 
      }, { status: 400 });
    }

    const data = parsed.data;
    const templateEngine = new TemplateEngine();

    let aiContent = '';
    try {
      if (process.env.OPENAI_API_KEY && !process.env.OPENAI_API_KEY.includes('placeholder')) {
        aiContent = await generateDocumentContent(
          data.documentType,
          {
            businessName: data.businessName,
            firstName: data.placeholders.firstName || '',
            lastName: data.placeholders.lastName || '',
            address: data.placeholders.address || '',
            phone: data.placeholders.phone || '',
            email: data.placeholders.email || '',
            abn: data.placeholders.abn,
            acn: data.placeholders.acn,
          },
          data.industry
        );
      } else {
        aiContent = `This is a sample ${data.documentType} document for ${data.businessName} in the ${data.industry} industry. This content would normally be generated by AI but is using fallback content for development purposes.`;
      }
    } catch (error) {
      console.warn('OpenAI API call failed, using fallback content:', error);
      aiContent = `This is a sample ${data.documentType} document for ${data.businessName} in the ${data.industry} industry. This content would normally be generated by AI but is using fallback content due to API issues.`;
    }

    const templateData = {
      ...data,
      branding: data.branding || {},
      placeholders: {
        ...data.placeholders,
        AI_CONTENT: aiContent,
      },
    };

    const files: any[] = [];

    if (data.format.includes('pdf')) {
      const html = await templateEngine.buildHtmlFromTemplates(templateData);
      const businessInfo: BusinessInfo = {
        businessName: data.businessName,
        abn: data.placeholders.abn || 'Not provided',
        industry: data.industry,
        address: data.placeholders.address,
        phone: data.placeholders.phone,
        email: data.placeholders.email,
        acn: data.placeholders.acn,
      };
      const pdfBuffer = await generatePdf(data.documentType, html, businessInfo);
      
      files.push({
        type: 'pdf',
        buffer: pdfBuffer,
        mimeType: 'application/pdf',
      });
    }

    if (data.format.includes('docx')) {
      const docxBuffer = await templateEngine.buildDocxFromTemplates(templateData);
      files.push({
        type: 'docx',
        buffer: docxBuffer,
        mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      });
    }

    const storedFiles = await Promise.all(
      files.map(async (file) => {
        const fileName = `${data.businessName.replace(/[^a-zA-Z0-9]/g, '_')}_${data.documentType.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.${file.type}`;
        
        return {
          type: file.type,
          url: `/api/download/${crypto.randomUUID()}?type=${file.type}`,
          fileName,
          data: file.buffer.toString('base64'),
          mimeType: file.mimeType,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        };
      })
    );

    const { data: document, error: dbError } = await supabase
      .from('generated_documents')
      .insert({
        user_id: body.userId || null,
        title: `${data.documentType} - ${data.businessName}`,
        document_type: data.documentType,
        industry: data.industry,
        format: data.format.join(','),
        business_info: templateData,
        metadata: {
          files: storedFiles.map(f => ({ type: f.type, fileName: f.fileName })),
          generatedAt: new Date().toISOString(),
        }
      })
      .select()
      .single();

    if (dbError) {
      console.error('Database error:', dbError);
    }

    return NextResponse.json({
      success: true,
      id: crypto.randomUUID(),
      files: storedFiles,
      meta: {
        title: data.documentType,
        industry: data.industry,
        documentType: data.documentType,
      },
    });

  } catch (error: any) {
    console.error('Document generation error:', error);
    return NextResponse.json({
      error: 'Internal Server Error',
      details: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
    }, { status: 500 });
  }
}

// GET endpoint to retrieve user's generated documents
export async function GET(req: NextRequest) {
  const supabase = getServiceRoleClient();
  const { searchParams } = new URL(req.url);
  const userId = searchParams.get('userId');

  if (!userId) {
    return NextResponse.json({
      error: 'Missing userId parameter'
    }, { status: 400 });
  }

  try {
    const { data: documents, error } = await supabase
      .from('generated_documents')
      .select('id, title, document_type, industry, format, created_at, metadata')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    return NextResponse.json({
      success: true,
      documents: documents || []
    });

  } catch (error: any) {
    console.error('Error fetching documents:', error);
    return NextResponse.json({
      error: 'Failed to fetch documents',
      details: error.message
    }, { status: 500 });
  }
}
